// Generated by CoffeeScript 1.4.0
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['core/drawingArea', 'core/guesser'], function(DrawingArea, Guesser) {
  var DrawThisGame;
  return DrawThisGame = (function(_super) {

    __extends(DrawThisGame, _super);

    DrawThisGame.prototype.entities = [];

    DrawThisGame.prototype.drawingArea = null;

    DrawThisGame.prototype.players = {};

    DrawThisGame.prototype.user = {
      timeElapsed: 0,
      lastMouse: {
        x: 0,
        y: 0
      }
    };

    DrawThisGame.prototype.isInsideUIThing = function(thing) {
      return atom.input.mouse.x >= thing.x && atom.input.mouse.x < thing.x + thing.w && atom.input.mouse.y >= thing.y && atom.input.mouse.y < thing.y + thing.h;
    };

    DrawThisGame.prototype.findUIThing = function(thing) {};

    DrawThisGame.prototype.mode = {
      current: 'waitfordrawing',
      waitfordrawing: function(dt) {
        if (atom.input.down('touchfinger') || atom.input.down('mouseleft')) {
          if (this.isInsideUIThing(this.drawingArea)) {
            this.mode.current = 'drawing';
          }
        }
        return this.user.lastMouse = {
          x: atom.input.mouse.x,
          y: atom.input.mouse.y
        };
      },
      drawing: function(dt) {
        var lastLine, x, y, _ref;
        if (atom.input.released('touchfinger') || atom.input.released('mouseleft')) {
          return this.mode.current = 'waitfordrawing';
        } else {
          _ref = [atom.input.mouse.x, atom.input.mouse.y], x = _ref[0], y = _ref[1];
          if (x > this.drawingArea.x + this.drawingArea.w) {
            x = this.drawingArea.x + this.drawingArea.w;
          } else if (x < this.drawingArea.x) {
            x = this.drawingArea.x;
          }
          if (y > this.drawingArea.y + this.drawingArea.h) {
            y = this.drawingArea.y + this.drawingArea.h;
          } else if (y < this.drawingArea.y) {
            y = this.drawingArea.y;
          }
          lastLine = this.drawingArea[this.drawingArea.length - 1];
          if (!(lastLine != null) || ((lastLine != null) && lastLine.x1 !== this.user.lastMouse.x && lastLine.x2 !== x && lastLine.y1 !== this.user.lastMouse.y && lastLine.y2 !== y)) {
            this.drawingArea.drawing.push({
              x1: this.user.lastMouse.x,
              y1: this.user.lastMouse.y,
              x2: x,
              y2: y
            });
          }
          return this.user.lastMouse = {
            x: x,
            y: y
          };
        }
      },
      predrawing: function(dt) {
        return this.updateEntities();
      }
    };

    DrawThisGame.prototype.draw = function() {
      var i, k, margin, v, _ref;
      atom.context.clear();
      this.drawingArea.draw();
      i = 0;
      margin = 16;
      _ref = this.players;
      for (k in _ref) {
        v = _ref[k];
        if (v.draw != null) {
          v.draw(margin + i * (Guesser.W + margin), 432);
          i++;
        }
      }
    };

    function DrawThisGame() {
      this.registerInputs();
      this.drawingArea = new DrawingArea();
      this.players.jim = new Guesser({
        name: 'Jim'
      });
      this.players.andrew = new Guesser({
        name: 'Andrew'
      });
    }

    DrawThisGame.prototype.registerInputs = function() {
      atom.input.bind(atom.button.LEFT, 'mouseleft');
      return atom.input.bind(atom.touch.TOUCHING, 'touchfinger');
    };

    DrawThisGame.prototype.update = function(dt) {
      return this.mode[this.mode.current].apply(this, [dt]);
    };

    return DrawThisGame;

  })(atom.Game);
});
