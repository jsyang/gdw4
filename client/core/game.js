// Generated by CoffeeScript 1.4.0
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['core/playerCard', 'core/predrawingArea', 'core/drawingArea', 'core/chat', 'core/timer', 'core/word'], function(PlayerCard, PredrawingArea, DrawingArea, Chat, Timer, Word) {
  var DrawThisGame;
  return DrawThisGame = (function(_super) {

    __extends(DrawThisGame, _super);

    DrawThisGame.prototype.user = {
      cardsX: 0,
      timeElapsed: 0,
      lastMouse: {
        x: 0,
        y: 0
      }
    };

    DrawThisGame.prototype.isPointInsideUIThing = function(point, thing) {
      return point.x >= thing.x && point.x < thing.x + thing.w && point.y >= thing.y && point.y < thing.y + thing.h;
    };

    DrawThisGame.prototype.findUIThing = function(thing) {};

    DrawThisGame.prototype.clampMouseInsideDrawingArea = function() {
      var x, y, _ref;
      _ref = [atom.input.mouse.x, atom.input.mouse.y], x = _ref[0], y = _ref[1];
      if (x > this.drawingArea.x + this.drawingArea.w) {
        x = this.drawingArea.x + this.drawingArea.w;
      } else if (x < this.drawingArea.x) {
        x = this.drawingArea.x;
      }
      if (y > this.drawingArea.y + this.drawingArea.h) {
        y = this.drawingArea.y + this.drawingArea.h;
      } else if (y < this.drawingArea.y) {
        y = this.drawingArea.y;
      }
      return {
        x: x,
        y: y
      };
    };

    DrawThisGame.prototype.mode = {
      current: 'predrawing',
      waitingforready: function(dt) {},
      waitingforguess: function(dt) {},
      predrawing: function(dt) {
        var w, _i, _j, _len, _len1, _ref, _ref1;
        if (atom.input.released('touchfinger') || atom.input.released('mouseleft')) {
          if (this.isPointInsideUIThing(atom.input.mouse, this.predrawingArea.button.ok)) {
            if (this.predrawingArea.chosen.length === 2) {
              this.drawingArea.chosen = this.predrawingArea.chosen;
              this.mode.current = 'waitfordrawing';
              this.drawingArea.draw();
            }
          } else if (this.isPointInsideUIThing(atom.input.mouse, this.predrawingArea.button.reset)) {
            this.predrawingArea.chosen = [];
            _ref = this.predrawingArea.words;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              w = _ref[_i];
              w.chosen = false;
            }
            this.predrawingArea.draw();
          } else if (this.predrawingArea.chosen.length < 2) {
            _ref1 = this.predrawingArea.words;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              w = _ref1[_j];
              if (this.isPointInsideUIThing(atom.input.mouse, w)) {
                w.chosen = true;
                this.predrawingArea.chosen.push(w.value);
                break;
              }
            }
            this.predrawingArea.draw();
          }
        }
      },
      waitfordrawing: function(dt) {
        if (atom.input.down('touchfinger') || atom.input.down('mouseleft')) {
          if (this.isPointInsideUIThing(atom.input.mouse, this.drawingArea)) {
            this.mode.current = 'drawing';
            this.user.timeElapsed = 0;
          }
        }
        return this.user.lastMouse = {
          x: atom.input.mouse.x,
          y: atom.input.mouse.y
        };
      },
      drawing: function(dt) {
        var lastLine, pen;
        this.user.timeElapsed += dt;
        if (atom.input.released('touchfinger') || atom.input.released('mouseleft')) {
          this.mode.current = 'waitfordrawing';
          if (this.user.timeElapsed > 0.03) {
            pen = this.clampMouseInsideDrawingArea();
            this.drawingArea.add({
              x1: this.user.lastMouse.x,
              y1: this.user.lastMouse.y,
              x2: pen.x + 0.5,
              y2: pen.y + 0.5
            });
            this.user.timeElapsed = 0;
            return this.user.lastMouse = {
              x: pen.x,
              y: pen.y
            };
          }
        } else {
          pen = this.clampMouseInsideDrawingArea();
          lastLine = this.drawingArea[this.drawingArea.length - 1];
          if (!(lastLine != null) || ((lastLine != null) && lastLine.x1 !== this.user.lastMouse.x && lastLine.x2 !== pen.x && lastLine.y1 !== this.user.lastMouse.y && lastLine.y2 !== pen.y)) {
            this.drawingArea.add({
              x1: this.user.lastMouse.x,
              y1: this.user.lastMouse.y,
              x2: pen.x,
              y2: pen.y
            });
          }
          return this.user.lastMouse = {
            x: pen.x,
            y: pen.y
          };
        }
      }
    };

    DrawThisGame.prototype.draw = function() {
      var c, _i, _len, _ref;
      this.timer.draw();
      _ref = this.playerCards;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        c.draw();
      }
    };

    DrawThisGame.prototype.network = {
      socket: null,
      name: null,
      role: null,
      whoseTurn: 'SomeOtherPlayer',
      sendName: function() {
        var sock,
          _this = this;
        sock = this.network.socket;
        this.network.name = prompt('Your name', 'Player');
        this.network.role = prompt('d for drawer, g for guesser', 'd');
        sock.emit('playerJoin', {
          playerName: this.network.name,
          role: this.network.role
        });
        switch (this.network.role) {
          case 'g':
            this.mode.current = 'waitingforguess';
            return sock.on('canvas', function(response) {
              return _this.network.receiveCanvas.call(_this, response);
            });
          case 'd':
            this.mode.current = 'predrawing';
            return this.predrawingArea.draw();
        }
      },
      receiveCanvas: function(response) {
        this.drawingArea.drawing = response.lines;
        return this.drawingArea.draw();
      },
      connectedToServer: false
    };

    DrawThisGame.prototype.addPlayer = function(player) {
      this.playerCards.push(new PlayerCard({
        name: player.name,
        x: this.user.cardsX,
        game: this
      }));
      this.user.cardsX += PlayerCard.W + PlayerCard.MARGIN;
      return this.playerCards;
    };

    DrawThisGame.prototype.removePlayer = function(player) {
      var found, p, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.playerCards;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (player.name === p.name) {
          found = p;
          break;
        }
      }
      if (found != null) {
        this.user.cardsX -= PlayerCard.W + PlayerCard.MARGIN;
        found.clear();
        this.playerCards.splice(this.playerCards.indexOf(found), 1);
        _ref1 = this.playerCards;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          p = _ref1[_j];
          p.clear();
          p.reorganize();
        }
      }
      return this.playerCards;
    };

    function DrawThisGame() {
      var uiParams, w, wlist, _i, _len;
      this.registerInputs();
      this.registerEvents();
      uiParams = {
        game: this
      };
      this.predrawingArea = new PredrawingArea(uiParams);
      this.drawingArea = new DrawingArea(uiParams);
      this.chat = new Chat(uiParams);
      this.timer = new Timer(uiParams);
      this.playerCards = [];
      this.user.cardsX += this.drawingArea.x;
      this.addPlayer({
        name: 'Jim'
      });
      wlist = ['dog', 'cat', 'rat', 'car', 'hat', 'bacon', 'tasty', 'nasty', 'yummy', 'long-winded', 'tuesday'];
      for (_i = 0, _len = wlist.length; _i < _len; _i++) {
        w = wlist[_i];
        this.predrawingArea.add(new Word({
          value: w
        }));
      }
      this.predrawingArea.draw();
      this.registerNetwork();
      return;
    }

    DrawThisGame.prototype.registerNetwork = function() {
      var _this = this;
      this.network.socket = io.connect('http://localhost:8000');
      this.network.socket.on('welcome', function() {
        _this.network.connectedToServer = true;
        return _this.network.sendName.apply(_this);
      });
    };

    DrawThisGame.prototype.registerEvents = function() {
      var _this = this;
      return atom.resizeCb = function() {
        _this.drawingArea.draw();
        _this.chat.resize().draw();
        _this.timer.resize().draw();
      };
    };

    DrawThisGame.prototype.registerInputs = function() {
      atom.input.bind(atom.button.LEFT, 'mouseleft');
      return atom.input.bind(atom.touch.TOUCHING, 'touchfinger');
    };

    DrawThisGame.prototype.timeLeft = function() {
      return 79310;
    };

    DrawThisGame.prototype.update = function(dt) {
      return this.mode[this.mode.current].apply(this, [dt]);
    };

    return DrawThisGame;

  })(atom.Game);
});
