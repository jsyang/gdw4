// Generated by CoffeeScript 1.4.0
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['core/network', 'core/playerCard', 'core/predrawingArea', 'core/drawingArea', 'core/chat', 'core/timer', 'core/word'], function(Network, PlayerCard, PredrawingArea, DrawingArea, Chat, Timer, Word) {
  var DrawThisGame;
  return DrawThisGame = (function(_super) {

    __extends(DrawThisGame, _super);

    DrawThisGame.prototype.user = {
      cardsX: 16,
      timeElapsed: 0,
      lastMouse: {
        x: 0,
        y: 0
      }
    };

    DrawThisGame.prototype.isPointInsideUIThing = function(point, thing) {
      return point.x >= thing.x && point.x < thing.x + thing.w && point.y >= thing.y && point.y < thing.y + thing.h;
    };

    DrawThisGame.prototype.findUIThing = function(thing) {};

    DrawThisGame.prototype.clampMouseInsideDrawingArea = function() {
      var x, y, _ref;
      _ref = [atom.input.mouse.x, atom.input.mouse.y], x = _ref[0], y = _ref[1];
      if (x > this.drawingArea.x + this.drawingArea.w) {
        x = this.drawingArea.x + this.drawingArea.w;
      } else if (x < this.drawingArea.x) {
        x = this.drawingArea.x;
      }
      if (y > this.drawingArea.y + this.drawingArea.h) {
        y = this.drawingArea.y + this.drawingArea.h;
      } else if (y < this.drawingArea.y) {
        y = this.drawingArea.y;
      }
      return {
        x: x,
        y: y
      };
    };

    DrawThisGame.prototype.mode = {
      init: function() {
        switch (this.network.role) {
          case 'g':
            this.mode.current = 'waitingforguess';
            break;
          case 'd':
            this.mode.current = 'predrawing';
        }
      },
      current: 'predrawing',
      waitingforready: function(dt) {},
      waitingforguess: function(dt) {},
      predrawing: function(dt) {
        var w, _i, _j, _len, _len1, _ref, _ref1;
        if (atom.input.released('touchfinger') || atom.input.released('mouseleft')) {
          if (this.isPointInsideUIThing(atom.input.mouse, this.predrawingArea.button.ok)) {
            if (this.predrawingArea.chosen.length === 2) {
              this.drawingArea.chosen = this.predrawingArea.chosen;
              this.mode.current = 'waitfordrawing';
              this.drawingArea.draw();
            }
          } else if (this.isPointInsideUIThing(atom.input.mouse, this.predrawingArea.button.reset)) {
            this.predrawingArea.chosen = [];
            _ref = this.predrawingArea.words;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              w = _ref[_i];
              w.chosen = false;
            }
            this.predrawingArea.draw();
          } else if (this.predrawingArea.chosen.length < 2) {
            _ref1 = this.predrawingArea.words;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              w = _ref1[_j];
              if (this.isPointInsideUIThing(atom.input.mouse, w)) {
                w.chosen = true;
                this.predrawingArea.chosen.push(w.value);
                break;
              }
            }
            this.predrawingArea.draw();
            atom.playSound('tick');
          }
        }
      },
      waitfordrawing: function(dt) {
        if (atom.input.down('touchfinger') || atom.input.down('mouseleft')) {
          if (this.isPointInsideUIThing(atom.input.mouse, this.drawingArea)) {
            this.mode.current = 'drawing';
            this.user.timeElapsed = 0;
          }
        }
        return this.user.lastMouse = {
          x: atom.input.mouse.x,
          y: atom.input.mouse.y
        };
      },
      drawing: function(dt) {
        var lastLine, pen;
        this.user.timeElapsed += dt;
        if (atom.input.released('touchfinger') || atom.input.released('mouseleft')) {
          this.mode.current = 'waitfordrawing';
          if (this.user.timeElapsed > 0.03) {
            pen = this.clampMouseInsideDrawingArea();
            this.drawingArea.add({
              x1: this.user.lastMouse.x,
              y1: this.user.lastMouse.y,
              x2: pen.x + 0.5,
              y2: pen.y + 0.5
            });
            this.user.timeElapsed = 0;
            return this.user.lastMouse = {
              x: pen.x,
              y: pen.y
            };
          }
        } else {
          pen = this.clampMouseInsideDrawingArea();
          lastLine = this.drawingArea[this.drawingArea.length - 1];
          if (!(lastLine != null) || ((lastLine != null) && lastLine.x1 !== this.user.lastMouse.x && lastLine.x2 !== pen.x && lastLine.y1 !== this.user.lastMouse.y && lastLine.y2 !== pen.y)) {
            this.drawingArea.add({
              x1: this.user.lastMouse.x,
              y1: this.user.lastMouse.y,
              x2: pen.x,
              y2: pen.y
            });
          }
          return this.user.lastMouse = {
            x: pen.x,
            y: pen.y
          };
        }
      }
    };

    DrawThisGame.prototype.addPlayer = function(player) {
      this.playerCards.push(new PlayerCard({
        name: player.name,
        x: this.user.cardsX,
        game: this
      }));
      this.user.cardsX += PlayerCard.W + PlayerCard.MARGIN;
      return this.playerCards;
    };

    DrawThisGame.prototype.removePlayer = function(player) {
      var found, p, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.playerCards;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (player.name === p.name) {
          found = p;
          break;
        }
      }
      if (found != null) {
        this.user.cardsX -= PlayerCard.W + PlayerCard.MARGIN;
        found.clear();
        this.playerCards.splice(this.playerCards.indexOf(found), 1);
        _ref1 = this.playerCards;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          p = _ref1[_j];
          p.clear();
          p.reorganize();
        }
      }
      return this.playerCards;
    };

    function DrawThisGame() {
      var uiParams;
      this.registerInputs();
      this.registerEvents();
      uiParams = {
        game: this
      };
      this.predrawingArea = new PredrawingArea(uiParams);
      this.drawingArea = new DrawingArea(uiParams);
      this.chat = new Chat(uiParams);
      this.timer = new Timer(uiParams);
      this.playerCards = [];
      this.network = new Network($$.extend(uiParams, {
        socket: io.connect('http://localhost:8000')
      }));
      return;
    }

    DrawThisGame.prototype.registerEvents = function() {
      var _this = this;
      atom.resizeCb = function() {
        _this.drawingArea.draw();
        _this.chat.resize().draw();
        _this.timer.resize().draw();
      };
    };

    DrawThisGame.prototype.registerInputs = function() {
      atom.input.bind(atom.button.LEFT, 'mouseleft');
      atom.input.bind(atom.touch.TOUCHING, 'touchfinger');
    };

    DrawThisGame.prototype.timeLeft = function() {
      return 79310;
    };

    DrawThisGame.prototype.update = function(dt) {
      return this.mode[this.mode.current].apply(this, [dt]);
    };

    DrawThisGame.prototype.draw = function() {
      return this.timer.draw();
    };

    return DrawThisGame;

  })(atom.Game);
});
